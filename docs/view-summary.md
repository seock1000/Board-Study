### 조회 수 요약

조회수는 게시글이 조회된 수만 저장
- 다른 데이터의 개수에 영향 X
- 전체 조회 수를 비정규화 상태로 단일 레코드에 바로 저장해도 충분
  - tx start -> 조회 수 갱신 -> tx commit
- 조회수 vs 댓글, 좋아요 수
  - 데이터 일관성
    - 댓글, 좋아요: 원본 데이터가 존재하므로 불일치 발생 시 사용자가 인지하게 되므로 중요
    - 조회수: 원본 데이터가 없으므로 드물게 불일치 발생 시 사용자가 인지하지 못함 -> 비교적 덜 중요
  - 쓰기 트래픽
    - 댓글, 좋아요: 상대적으로 낮음 -> 사용자의 직접적인 액션이 필요
    - 조회수: 상대적으로 높음 -> 페이지 로드 시마다 발생 가능
- 댓글, 좋아요 수는 RDB의 트랜잭션을 사용
  - 데이터의 일관성을 관리, 안전한 저장소에 영구 저장
  - 디스크 접근 비용과 트랜잭션 관리 비용 발생
- 조회수는 메모리 저장소(In-memory DB)를 사용
  - 데이터 일관성이 덜 중요하여 트랜잭션, 안전한 저장소가 크게 필요하지 않음 - Redis의 AOF, RDB 백업 기능으로 적정선의 데이터 유실 방지 가능
    - MySQL에 자체적인 BackUp 기능 구현 예정 - 주기적으로 조회수를 RDB에 저장
  - 트래픽이 많기 때문에 디스크 접근 비용을 줄이는 것이 중요

- 디스크 vs 메모리
  - 속도
    - 디스크(느림) vs 메모리(빠름)
  - 휘발성
    - 디스크(영구 저장) vs 메모리(휘발성)
  - 용량
    - 디스크(큼) vs 메모리(작음)
  - 가격(용량대비)
    - 디스크(저렴) vs 메모리(비쌈)

- Redis
  - NoSQL: 정해진 스키마 없이 다양한 형태의 데이터를 저장 가능(key-value)
  - In-memory DB: 메모리에 데이터를 저장하여 빠른 속도 제공
  - 다양한 데이터 구조 지원: 문자열, 해시, 리스트, 셋, 정렬
  - 복제 및 클러스터링 지원: 데이터 복제 및 분산 저장 가능
  - TTL 지원: 데이터의 유효 기간 설정 가능
  - Single-threaded: 단일 스레드로 동작하여 각 명령어를 순차적 처리하므로 동시성 문제 해결에 유리
  - 데이터 백업 지원: 메모리 데이터를 디스크에 백업하여 데이터 유실 방지
    - AOF(Append Only File): 모든 쓰기 명령어를 로그 파일에 기록하고 재실행하여 복구
    - RDB(Snapshotting): 특정 시점의 데이터를 주기적으로 스냅샷으로 저장
  - 사용 사례
    - 고성능 작업
      - 상대적으로 빠르므로 Redis 자체를 데이터 베이스로 이용
      - Single-threaded로 동시성 문제 해결에 유리
    - Cache
      - DB의 부하를 줄이기 위해 자주 조회되는 데이터를 Redis에 캐싱
    - Pub/Sub
      - 메시지 구독/발행 기능으로 실시간 통신을 위한 메시지 큐로 사용 가능
  
  - Cluster
    - Redis의 분산 시스템 구성을 위한 클러스터링 기능
    - Redis를 수평적으로 확장할 수 있도록 지원
      - Sharding 지원
        - 확장성을 위한 Logical Shard: 16,384개 slot
        - Physical Shard: key의 해시값을 기준으로 slot에 매핑, slot이 속한 Physical Shard에 데이터 저장
          - slot = hash_func(key)
          - shard = select_shard(slot) 
        - 서버 확장시 자동으로 데이터 분산
        - 데이터 복제 기능 제공: 고가용성 
        
- 백업 전략
  - 시간단위 백업
    - 특정 주기로(N분마다) Redis 데이터를 디스크에 백업
    - Batch/Scheduling 기능 구축 필요
    - 백업 전 장애 유실가능성 존재
  - 개수단위 백업 - 사용 예정
    - N개의 쓰기 작업마다 Redis 데이터를 디스크에 백업
    - 조회 시점에 간단한 처리 가능
    - 백업 전 장애 유실 가능성 존재
    - 개수 단위를 만족하지 못할 시 유실 가능성 존재
  - 두 방식을 조합하는 것도 가능

## docker로 redis 실행
```bash
dockeer run --name seock1000-board-redis -d -p 6379:6379 redis:7.4
docker exec -it seock1000-board-redis redis-cli
```

## 어뷰징 방지
- 특정 게시글을 반복 조회하여 데이터 조작 가능성 존재
- 로그인 사용자(사용 예정)
  - 사용자별 식별가능
- 비로그인 사용자
  - IP, User-Agent, 쿠키 등으로 식별 가능

- 어뷰징 정책 설계
  - 10분 동안 여러번 조회하더라도 1회만 카운트(10분 내 2회 조회를 어뷰징으로 판단)
  - 10분 이내 조회 여부 확인 방법
    - DB 사용 방법
      - 조회 수 증가 요청시, 마지막 조회 시점을 조회
      - 10분 이내의 조회 내역이 있다면 조회 수 증가를 무시
      - 10분 이후라면 조회 수 증가 및 마지막 조회 시점 갱신
      - 문제점
        - 조회는 트래픽이 많음 -> DB 부하 증가
        - 동시요청 발생시 Lock 발생 가능성 -> 성능 저하
        - MySQL은 영구적으로 데이터를 저장 -> 주기적으로 오래된 데이터를 삭제하는 작업 필요
      - Redis 사용
        - In-memory DB로 빠른 조회 가능
        - Single-threaded로 동시성 문제 해결에 유리
        - 휘발성 데이터 저장 가능: TTL 설정 가능
          - 특정 시간(10분) 이후 자동 삭제 가능
        - 조회 수 증가 요청 시, Redis에서 마지막 조회 시점 확인
    - Redis 사용 방법
      - 조회 수 증가 요청이 오면, TTL 10분으로 데이터를 저장
        - key = article_id + user_id
        - setIfAbsent
          - 데이터가 없을 때만 저장, 성공/실패 시 true/false 반환
          - 이미 저장된 데이터가 있으면 저장에 실패하는 명령어 사용
        - 저장에 성공하면 조회 수 증가
        - 저장에 실패하면 조회 수 증가 무시
      - 분산락 방식: 조회 수 증가에 Lock을 획득한다고 볼 수 있음
        - 사용자+게시글의 조회 수 증가에 대해 10분간 락 획득