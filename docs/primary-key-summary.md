### PK 생성 전략
1. DB auto increment 사용
   - 장점: 단순하고 구현이 쉬움
     - 보안적인 문제를 크게 고려하지 않는 상황, 단일 DB 사용 또는 애플리케이션에서 PK 중복을 직접 관리하는 상황에서 사용
   - 단점: 
     - 분산 환경에서 충돌 가능성(식별자의 유일성 보장 X)
       - 분산 환경에서 여러 샤드에서 동일한 값이 생성될 수 있음
     - 클라이언트 측에 노출 시 보안 문제
       - ex) 방금 가입했더니 ID가 1000이면 1000명의 사용자가 있다는 것을 유추
       - 보안 문제만 염려되는 경우 PK는 DB 식별자로만 사용하고, 별도의 unique key를 클라이언트에 노출하는 방안 고려 가능
         - unique key를 사용하면 secondary index가 추가로 필요하여 조회 성능 저하 발생 가능
2. UUID/난수 사용
   - 정렬 데이터가 아닌 랜덤 데이터를 삽입하는 방식
   - 장점
     - 키 생성 방식이 간단
   - 단점
     - 랜덤 데이터로 인한 성능저하 발생
       - Clustered Index는 정렬된 상태를 유지하므로 새로운 데이터가 삽입될 때마다 B+tree 재구성 / 페이지 분할이 발생하여 성능 저하
       - 범위 조회 시, 랜덤 I/O 발생으로 성능 저하
3. Unique 정렬 문자열
   - UUID v7, ULID 등 알고리즘을 사용하여 순차적인 식별자 생성
   - 장점
     - 분산환경에서 충돌 가능성 낮음
     - 보안문제 해결
     - 정렬된 상태로 삽입되어 성능 저하 문제 해결
   - 단점
     - 데이터 크기에 따라 공간/성능 효율이 상이
       - 일반적으로 알려진 알고리즘은 128비트
       - Secondary Index는 데이터 접근을 위한 포인터(PK)를 포함
       - PK가 클수록 데이터는 더 많은 공간을 차지하며, 비교 연산을 위한 정렬/조회에 더 많은 비용 소모
4. Unique 정렬 숫자
    - Snowflake, TSID 등 알고리즘을 사용하여 순차적인 숫자 생성
    - 장점
      - 분산환경에서 충돌 가능성 낮음
      - 보안문제 해결
      - 정렬된 상태로 삽입되어 성능 저하 문제 해결
      - 숫자는 문자열보다 공간 효율이 좋음
         - 64비트 정수형은 20자리 십진수 표현 가능
         - Secondary Index의 공간 효율이 더 좋음
    - 단점
      - 정렬을 위해 타임스탬프를 나타내는 비트 수의 제한으로
        - 키 생성을 위한 시간적 한계 존재
        - 문자열 알고리즘에서도 동일한 한계점이 존재하나 비트 수가 적을수록 제한이 큼